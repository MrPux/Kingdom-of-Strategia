<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">

<head>
    <meta charset="UTF-8">
    <!-- Sets the title of the page dynamically using Thymeleaf -->
    <title th:text="'Village of ' + ${village.name}">Village Info</title>
    <!-- Cytoscape.js library for graph visualization -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.21.0/cytoscape.min.js"
        crossorigin="anonymous"></script>

    <style>
        /* Basic styling for the page */
        body {
            font-family: sans-serif;
            background-color: #f4f4f4;
            padding: 0;
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: row;
            justify-content: flex-start;
            align-items: flex-start;
            overflow: hidden;
        }

        /* Style for the village information card on the left */
        .village-card {
            background-color: #fff;
            border-radius: 12px;
            padding: 20px 25px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
            width: 400px;
            height: auto;
            max-height: 90vh;
            overflow-y: auto;
            margin: 40px 20px 0 40px;
            color: #454e4e;
            font-weight: bold;
        }

        /* Style for the village image */
        .village-card img {
            width: 100px;
            height: auto;
            margin-bottom: 15px;
        }

        /* Style for the graph section on the right */
        .graph-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 40px;
            flex-grow: 1;
        }

        /* Style for the graph canvas */
        #negative-cycle-graph {
            flex-grow: 1;
            margin: 20px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
            background-color: #ffffff;
            border-radius: 12px;
            height: calc(70vh);
            /* Graph height smaller to leave space for bottom cards */
            width: 80%;
        }

        /* Style for the bottom cards container */
        .bottom-cards {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 20px;
            gap: 20px;
        }

        /* Style for the square cards */
        .square-card {
            background-color: white;
            width: 150px;
            height: 150px;
            border-radius: 12px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #454e4e;
            transition: transform 0.3s, box-shadow 0.3s;
        }

        /* Hover effect for the square cards */
        .square-card:hover {
            transform: scale(1.05);
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.2);
        }
    </style>
</head>

<body>

    <!-- Left Side Village Info - Contains details about the selected village -->
    <div class="village-card">
        <!-- Village Name - Dynamically set using Thymeleaf -->
        <h1 th:text="${village.formattedName}">Village Name</h1>
        <!-- Village Sprite - Dynamically set using Thymeleaf to display the village's image -->
        <img th:src="@{${village.sprite}}" alt="Village Sprite" />
        <!-- Village Population - Dynamically set using Thymeleaf -->
        <p><strong>Population:</strong> <span th:text="${village.population}">0</span></p>
        <!-- Village Structures - Dynamically set using Thymeleaf -->
        <p><strong>Structures:</strong> <span th:text="${village.structures}">0</span></p>
        <!-- Village Coordinates - Dynamically set using Thymeleaf -->
        <p><strong>Coordinates:</strong> (<span th:text="${village.xCoordinate}">x</span>, <span
                th:text="${village.yCoordinate}">y</span>)</p>
        <hr>
        <!-- Village Resources Section -->
        <h3>Resources</h3>
        <!-- Food Resource - Dynamically set using Thymeleaf -->
        <p><strong>Food:</strong> <span th:text="${village.food}">0</span></p>
        <!-- Wood Resource - Dynamically set using Thymeleaf -->
        <p><strong>Wood:</strong> <span th:text="${village.wood}">0</span></p>
        <!-- Rocks Resource - Dynamically set using Thymeleaf -->
        <p><strong>Rocks:</strong> <span th:text="${village.rocks}">0</span></p>
        <!-- Iron Resource - Dynamically set using Thymeleaf -->
        <p><strong>Iron:</strong> <span th:text="${village.iron}">0</span></p>
        <!-- Coal Resource - Dynamically set using Thymeleaf -->
        <p><strong>Coal:</strong> <span th:text="${village.coal}">0</span></p>
        <!-- Villagers Count - Dynamically set using Thymeleaf -->
        <p><strong>Villagers:</strong> <span th:text="${village.villagers}">0</span></p>
        <!-- Knights Count - Dynamically set using Thymeleaf -->
        <p><strong>Knights:</strong> <span th:text="${village.knights}">0</span></p>
        <!-- Back to Map Link - A link to return to the main map -->
        <a href="/hello" style="color:#009a7e; text-decoration: none;">‚Üê Back to Map</a>
    </div>

    <!-- Right Side Graph + Cards - Contains the graph visualization and algorithm selection cards -->
    <div class="graph-section">
        <!-- Graph Canvas - Where the Cytoscape graph will be rendered -->
        <div id="negative-cycle-graph"></div>

        <div id="finalize-notice" style="display: none; padding: 10px 15px; margin: 10px auto; background-color: #058963a4; 
        border: 1px solid #00ffbb9b; border-radius: 8px; color: #ffffff; font-weight: bold; 
        width: 60%; text-align: center;">
            üõ°Ô∏è Best Path calculation complete!
        </div>
        <!-- Notification for Algorithm Info - Displays a warning if Dijkstra's algorithm cannot be used -->
        <div id="algorithm-notice"
            style="display: none; padding: 15px 20px; margin: 20px auto; background-color: #ffe0e0; border: 1px solid #ff6b6b; border-radius: 10px; color: #a40000; font-weight: bold; width: 80%; text-align: center;">
            ‚ö†Ô∏è Dijkstra cannot be used due to negative edges. Try Bellman-Ford or Floyd-Warshall instead!
        </div>


        <!-- Bottom Cards - Algorithm selection cards -->
        <div class="bottom-cards">
            <!-- Dijkstra Card - Card to trigger Dijkstra's algorithm animation -->
            <div class="square-card" id="dijkstra-card">Dijkstra</div>
            <!-- Bellman-Ford Card - Card to trigger Bellman-Ford algorithm animation -->
            <div class="square-card" id="Bellman-Ford-card">Bellman-Ford</div>
            <!-- Floyd-Warshall Card - Card to trigger Floyd-Warshall algorithm animation -->
            <div class="square-card" id="Floyd-Warshall-card">Floyd-Warshall</div>
            <!-- Add more cards if you want -->
        </div>
    </div>


    <!-- Cytoscape Graph Script - JavaScript code to render and interact with the graph -->
    <script th:inline="javascript">
        /*<![CDATA[*/
        // GLOBAL variables here:
        var parsedData = {}; // global
        var graphData = /*[[${graphData}]]*/ '[]'; // global graph JSON
        var animationSteps = /*[[${animationSteps}]]*/ '[]'; // global Dijkstra animation JSON
        var cy; // global Cytoscape instance

        // Event listener that triggers when the document is fully loaded
        document.addEventListener('DOMContentLoaded', function () {
            try {
                // Parse the graph data from JSON format
                parsedData = JSON.parse(graphData);

                // Initialize Cytoscape graph
                cy = cytoscape({
                    container: document.getElementById('negative-cycle-graph'),
                    elements: parsedData.nodes.concat(parsedData.edges),
                    style: [
                        {
                            selector: 'node',
                            style: {
                                'background-image': 'data(houseSprite)',
                                'background-fit': 'contain',
                                'background-opacity': 0,
                                'shape': 'ellipse',
                                'border-width': 0,
                                'width': '60px',
                                'height': '60px',
                                'label': '',
                                'text-valign': 'bottom',
                                'text-halign': 'center',
                                'text-margin-y': 10,
                                'overlay-opacity': 0
                            }
                        },
                        {
                            selector: 'node[id = "fountain"]',
                            style: {
                                'label': '',
                                'width': '70px',
                                'height': '70px'
                            }
                        },
                        // Negative weights
                        {
                            selector: 'edge[weight < 0]',
                            style: {
                                'color': 'red',
                                'label': 'data(weight)',
                                'font-size': '12px',
                                'text-outline-width': 2,
                                'text-outline-color': 'white',
                                'text-background-color': 'white',
                                'text-background-opacity': 1,
                                'text-background-shape': 'roundrectangle',
                                'line-color': '#888',
                                'width': 3,
                                'curve-style': 'bezier',
                                'target-arrow-shape': 'triangle',
                                'target-arrow-color': '#888',
                                'mid-target-arrow-shape': 'vee',
                                'mid-target-arrow-color': '#888',
                                'mid-target-arrow-fill': 'hollow',
                                'arrow-scale': 1.5,
                                'opacity': 0.9,
                                'line-style': 'dashed',
                                'line-dash-pattern': [8, 4]
                            }
                        },
                        // Positive weights
                        {
                            selector: 'edge[weight >= 0]',
                            style: {
                                'color': 'green',
                                'label': 'data(weight)',
                                'font-size': '12px',
                                'text-outline-width': 2,
                                'text-outline-color': 'white',
                                'text-background-color': 'white',
                                'text-background-opacity': 1,
                                'text-background-shape': 'roundrectangle',
                                'line-color': '#888',
                                'width': 3,
                                'curve-style': 'bezier',
                                'target-arrow-shape': 'triangle',
                                'target-arrow-color': '#888',
                                'mid-target-arrow-shape': 'vee',
                                'mid-target-arrow-color': '#888',
                                'mid-target-arrow-fill': 'hollow',
                                'arrow-scale': 1.5,
                                'opacity': 0.9,
                                'line-style': 'dashed',
                                'line-dash-pattern': [8, 4]
                            }
                        },
                    ],
                    layout: {
                        name: 'cose',
                        animate: false
                    }
                });

                cy.fit(); // zoom graph to fit nicely

                // Animate dashed line movement (optional visual)
                let dashOffset = 0;
                setInterval(() => {
                    dashOffset = (dashOffset - 1) % 100;
                    cy.edges().forEach(edge => {
                        if (edge.style('line-style') === 'dashed') {  // ‚¨ÖÔ∏è Only if still dashed
                            edge.style('line-dash-offset', dashOffset);
                        }
                    });
                }, 60);


            } catch (e) {
                console.error("Error initializing Cytoscape:", e);
                document.getElementById('negative-cycle-graph').innerText = "Error: Could not render graph.";
            }
        });

        // ‚úÖ Dijkstra Animation Function - Animates Dijkstra's algorithm on the graph
        async function playDijkstraAnimation() {
            const steps = JSON.parse(animationSteps);
            const finalizedEdges = new Set(); // üü¢ to track final green connections

            for (const step of steps) {
                const edge = cy.edges().filter(e => {
                    return (e.source().id() === step.from && e.target().id() === step.to) ||
                        (e.source().id() === step.to && e.target().id() === step.from);
                });

                if (step.action === "visit") {
                    edge.forEach(e => {
                        e.style({
                            'line-color': 'orange',
                            'target-arrow-color': 'orange',
                            'line-style': 'solid',
                            'width': 4,
                            'line-dash-pattern': []
                        });
                        cy.$id(step.from).style({
                            'border-width': '4px',
                            'border-color': 'orange'
                        });
                        cy.$id(step.to).style({
                            'border-width': '4px',
                            'border-color': 'orange'
                        });
                    });
                } else if (step.action === "finalize") {
                    edge.forEach(e => {
                        e.style({
                            'line-color': 'green',
                            'target-arrow-color': 'green',
                            'line-style': 'solid',
                            'width': 5,
                            'line-dash-pattern': []
                        });
                        cy.$id(step.from).style({
                            'border-width': '4px',
                            'border-color': 'green'
                        });
                        cy.$id(step.to).style({
                            'border-width': '4px',
                            'border-color': 'green'
                        });

                        finalizedEdges.add(e.id()); // üü¢ Mark this edge as finalized
                    });
                }

                await new Promise(resolve => setTimeout(resolve, 500)); // small delay between steps
            }

            // ‚ú® After ALL animations, hide the remaining orange edges
            cy.edges().forEach(edge => {
                if (!finalizedEdges.has(edge.id())) {
                    // This edge was only visited, not finalized ‚Üí hide it
                    edge.style({
                        'opacity': 0.2,         // you can also use 0 if you want it invisible
                        'line-color': '#ccc',    // optional: gray color for "inactive" edges
                        'target-arrow-color': '#ccc'
                    });
                }
            });
        }

        // ‚úÖ BeellmanFord Animation Function - Animates BellmanFord's algorithm on the graph
        async function playBellmanFordAnimation() {
            const finalizedEdges = new Set(); // track which edges were finalized
            const finalizeNotice = document.getElementById('finalize-notice');

            // Phase 1: VISIT phase (blue)
            for (const step of visitSteps) {
                const edge = cy.edges().filter(edge =>
                    (edge.source().id() === step.from && edge.target().id() === step.to) ||
                    (edge.source().id() === step.to && edge.target().id() === step.from)
                );

                edge.forEach(e => {
                    e.style({
                        'line-color': '#D76400',
                        'target-arrow-color': '#D76400',
                        'line-style': 'solid',
                        'width': 4,
                        'line-dash-pattern': []
                    });
                    cy.$id(step.from).style({
                        'border-width': '4px',
                        'border-color': '#D76400'
                    });
                    cy.$id(step.to).style({
                        'border-width': '4px',
                        'border-color': '#D76400'
                    });
                });

                await new Promise(resolve => setTimeout(resolve, 8));  // small delay for each visit
            }

            // ‚úÖ AFTER ALL BLUE IS DONE, NOW SHOW "HANG TIGHT!"
            finalizeNotice.style.display = "block";
            finalizeNotice.style.opacity = 0;
            setTimeout(() => {
                finalizeNotice.style.transition = "opacity 0.5s ease-in";
                finalizeNotice.style.opacity = 1;
            }, 10);


            // Phase 2: FINALIZE phase (green)
            for (const step of finalizeSteps) {
                const edge = cy.edges().filter(edge =>
                    (edge.source().id() === step.from && edge.target().id() === step.to) ||
                    (edge.source().id() === step.to && edge.target().id() === step.from)
                );

                edge.forEach(e => {
                    e.style({
                        'line-color': 'green',
                        'target-arrow-color': 'green',
                        'line-style': 'solid',
                        'width': 5,
                        'line-dash-pattern': []
                    });
                    cy.$id(step.from).style({
                        'border-width': '4px',
                        'border-color': 'green'
                    });
                    cy.$id(step.to).style({
                        'border-width': '4px',
                        'border-color': 'green'
                    });
                    finalizedEdges.add(e.id());
                });
                await new Promise(resolve => setTimeout(resolve, 50));  // small delay for each visit
            }


            // ‚ú® Hide leftover blue edges (those that were only visited, not finalized)
            cy.edges().forEach(edge => {
                if (!finalizedEdges.has(edge.id())) {
                    edge.style({
                        'opacity': 0.2,
                        'line-color': '#ccc',
                        'target-arrow-color': '#ccc'
                    });
                }
            });

            // Hide "calculation complete!" message after finishing
            setTimeout(() => {
                finalizeNotice.style.transition = "opacity 0.5s ease-out";
                finalizeNotice.style.opacity = 0;
                setTimeout(() => {
                    finalizeNotice.style.display = "none";
                }, 500);
            }, 1000);
        }






        var hasNegativeEdge = /*[[${hasNegativeEdge}]]*/ false; // only declare ONCE

        const dijkstraCard = document.getElementById('dijkstra-card');
        const bellmanFordCard = document.getElementById('Bellman-Ford-card');
        const notice = document.getElementById('algorithm-notice');
        const bottomCards = document.querySelector('.bottom-cards'); // <-- get the cards container

        // Parse BellmanFord animation steps
        var bellmanFordAnimationSteps = /*[[${bellmanFordSteps}]]*/ '[]';
        bellmanFordAnimationSteps = JSON.parse(bellmanFordAnimationSteps);
        const visitSteps = bellmanFordAnimationSteps.filter(step => step.action === "visit");
        const finalizeSteps = bellmanFordAnimationSteps.filter(step => step.action === "finalize");


        // ‚úÖ Dijkstra Button Click - Handles the click event for the Dijkstra card
        dijkstraCard.addEventListener('click', () => {
            if (!hasNegativeEdge) {
                playDijkstraAnimation();
                console.log("‚úÖ Dijkstra animation triggered (no negative edges).");
            } else {
                console.log("‚ùå Negative edges detected: showing notice!");

                // ‚¨áÔ∏è Hide bottom cards
                bottomCards.style.display = "none";

                // ‚¨áÔ∏è Show notification
                notice.style.opacity = 0;
                notice.style.display = "block";
                setTimeout(() => {
                    notice.style.transition = "opacity 0.5s ease-in";
                    notice.style.opacity = 1;
                }, 10);

                // ‚¨áÔ∏è After 3 seconds, fade out notification
                setTimeout(() => {
                    notice.style.transition = "opacity 1s ease-out";
                    notice.opacity = 0;

                    // After fading out, hide the notice and bring back cards
                    setTimeout(() => {
                        notice.style.display = "none";
                        bottomCards.style.display = "flex"; // üëà bring back cards
                    }, 1000); // wait for fade out to finish
                }, 3000); // wait 3 seconds before starting fade
            }
        });

        // ‚úÖ BellmanFord Button Click - Handles the click event for the BellmanFord card
        bellmanFordCard.addEventListener('click', () => {
            playBellmanFordAnimation();
            console.log("üõ°Ô∏è Bellman-Ford animation triggered!");
        });


        /*]]>*/
    </script>


</body>

</html>