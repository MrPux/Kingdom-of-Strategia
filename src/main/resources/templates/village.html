<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">

<head>
    <meta charset="UTF-8">
    <!-- Sets the title of the page dynamically using Thymeleaf -->
    <title th:text="'Village of ' + ${village.name}">Village Info</title>
    <!-- Cytoscape.js library for graph visualization -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.21.0/cytoscape.min.js"
        crossorigin="anonymous"></script>

    <style>
        /* Basic styling for the page */
        body {
            min-height: 100vh;
            /* üåü important: at least full height, but can grow */
            overflow-y: auto;
            /* üåü allow vertical scroll if needed */
            margin: 0;
            padding: 0;
            font-family: sans-serif;
            display: flex;
            flex-direction: row;
            justify-content: flex-start;
            align-items: flex-start;
        }


        /* Style for the village information card on the left */
        .village-card {
            background-color: #fff;
            border-radius: 12px;
            padding: 20px 25px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
            width: 400px;
            height: auto;
            max-height: 90vh;
            overflow-y: auto;
            margin: 40px 20px 0 40px;
            color: #454e4e;
            font-weight: bold;
        }

        /* Style for the village image */
        .village-card img {
            width: 100px;
            height: auto;
            margin-bottom: 15px;
        }

        /* Style for the graph section on the right */
        .graph-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 40px;
            flex-grow: 1;
        }

        /* Style for the graph canvas */
        #negative-cycle-graph {
            flex-grow: 1;
            margin: 20px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
            background-color: #ffffff;
            border-radius: 12px;
            height: calc(70vh);
            /* Graph height smaller to leave space for bottom cards */
            width: 80%;
        }

        /* Style for the bottom cards container */
        .bottom-cards {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 20px;
            gap: 20px;
        }

        /* Style for the square cards */
        .square-card {
            background-color: white;
            width: 150px;
            height: 150px;
            border-radius: 12px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #454e4e;
            transition: transform 0.3s, box-shadow 0.3s;
        }

        /* Hover effect for the square cards */
        .square-card:hover {
            transform: scale(1.05);
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.2);
        }
    </style>
</head>

<body>

    <!-- Left Side Village Info - Contains details about the selected village -->
    <div class="village-card">
        <!-- Village Name - Dynamically set using Thymeleaf -->
        <h1 th:text="${village.formattedName}">Village Name</h1>
        <!-- Village Sprite - Dynamically set using Thymeleaf to display the village's image -->
        <img th:src="@{${village.sprite}}" alt="Village Sprite" />
        <!-- Village Population - Dynamically set using Thymeleaf -->
        <p><strong>Population:</strong> <span th:text="${village.population}">0</span></p>
        <!-- Village Structures - Dynamically set using Thymeleaf -->
        <p><strong>Structures:</strong> <span th:text="${village.structures}">0</span></p>
        <!-- Village Coordinates - Dynamically set using Thymeleaf -->
        <p><strong>Coordinates:</strong> (<span th:text="${village.xCoordinate}">x</span>, <span
                th:text="${village.yCoordinate}">y</span>)</p>
        <hr>
        <!-- Village Resources Section -->
        <div id="resources-section" style="margin-top: 10px;">
            <h3>Resources</h3>

            <!-- Message when not collected yet -->
            <p id="resources-message" style="color: #ca5400; font-weight: bold;">üß∫ Resources have yet to be
                collected...</p>

            <!-- Real resources (hidden initially) -->
            <div id="resources-list" style="display: none;">
                <p><strong>Food:</strong> <span th:text="${village.food}">0</span></p>
                <p><strong>Wood:</strong> <span th:text="${village.wood}">0</span></p>
                <p><strong>Rocks:</strong> <span th:text="${village.rocks}">0</span></p>
                <p><strong>Iron:</strong> <span th:text="${village.iron}">0</span></p>
                <p><strong>Coal:</strong> <span th:text="${village.coal}">0</span></p>
                <p><strong>Villagers:</strong> <span th:text="${village.villagers}">0</span></p>
                <p><strong>Knights:</strong> <span th:text="${village.knights}">0</span></p>
            </div>
        </div>

        <!-- Back to Map Link - A link to return to the main map -->
        <a href="/hello" style="color:#009a7e; text-decoration: none;">‚Üê Back to Map</a>
    </div>

    <!-- Right Side Graph + Cards - Contains the graph visualization and algorithm selection cards -->
    <div class="graph-section">
        <div id="total-cost-display"
            style="margin-top: 10px; font-size: 20px; font-weight: bold; color: #006400; display: none;">
            Total Cost: 0
        </div>
        <!-- Graph Canvas - Where the Cytoscape graph will be rendered -->
        <div id="negative-cycle-graph"></div>

        <div id="finalize-notice" style="display: none; padding: 10px 15px; margin: 10px auto; background-color: #058963; 
        border: 1px solid #00ffbb9b; border-radius: 8px; color: #ffffff; font-weight: bold; 
        width: 60%; text-align: center;">
            üõ°Ô∏è Best Path calculation completed!
        </div>

        <!-- Select Algorithm Button -->
        <div id="select-algorithm-button"
            style="display: none; margin-top: 10px; padding-bottom: 25px; text-align: center; z-index: 1000;">
            <button id="select-algorithm"
                style="padding: 15px 20px; font-size: 18px; background-color: #058963; color: white; border: none; border-radius: 10px; cursor: pointer;">
                Select current Algorithm
            </button>
        </div>
        <!-- Select another Algorithm Button -->
        <!-- <div id="select-algorithm-button"
            style="display: none; margin-top: 10px; padding-bottom: 25px; text-align: center; z-index: 1000;">
            <button id="select-algorithm"
                style="padding: 15px 20px; font-size: 18px; background-color: #893105; color: white; border: none; border-radius: 10px; cursor: pointer;">
                Select another Algorithm
            </button>
        </div> -->

        <div id="scout-messanger-button" style="display: none; margin-top: 20px; text-align: center;">
            <button id="scout-messanger"
                style="padding: 15px 20px; font-size: 18px; background-color: #058963; color: white; border: none; border-radius: 10px; cursor: pointer;">
                üìú Echo the old King‚Äôs Final Will
            </button>
        </div>

        <!-- Bottom Cards - Algorithm selection cards -->
        <div class="bottom-cards">
            <!-- Dijkstra Card - Card to trigger Dijkstra's algorithm animation -->
            <div class="square-card" id="dijkstra-card">Dijkstra</div>
            <!-- Floyd-Warshall Card - Card to trigger Floyd-Warshall algorithm animation -->
            <div class="square-card" id="Floyd-Warshall-card">Floyd-Warshall</div>
            <!-- Bellman-Ford Card - Card to trigger Bellman-Ford algorithm animation -->
            <div class="square-card" id="Bellman-Ford-card">Bellman-Ford</div>
        </div>

        <img id="messenger" src="/assets/messanger.png"
            style="position: absolute; width: 80px; height: auto; top: 0; left: 0; display: none; z-index: 10;">

    </div>


    <!-- Cytoscape Graph Script - JavaScript code to render and interact with the graph -->
    <script th:inline="javascript">
        /*<![CDATA[*/
        // GLOBAL variables here:
        const selectAlgorithmBtn = document.getElementById('select-algorithm');
        const scoutMessangerBtn = document.getElementById('scout-messanger');
        const villageId = /*[[${village.id}]]*/ 0;
        let totalCost = 0; // üõ°Ô∏è global tracker
        const totalCostDisplay = document.getElementById('total-cost-display');
        var parsedData = {}; // global
        var graphData = /*[[${graphData}]]*/ '[]'; // global graph JSON 
        var cy; // global Cytoscape instance
        let isAnimating = false;
        let animationSteps = []; // üõ°Ô∏è Global to store steps for messenger
        let finalizedPath = [];



        // Event listener that triggers when the document is fully loaded
        document.addEventListener('DOMContentLoaded', function () {
            isAnimating = false;   // ‚úÖ Reset animating flag
            totalCost = 0;         // ‚úÖ Reset cost

            if (cy) {
                cy.destroy(); // üî• DESTROY the old graph
            }

            try {
                // Parse the graph data from JSON format
                parsedData = JSON.parse(graphData);

                // Initialize Cytoscape graph
                cy = cytoscape({
                    container: document.getElementById('negative-cycle-graph'),
                    elements: parsedData.nodes.concat(parsedData.edges),
                    style: [
                        {
                            selector: 'node',
                            style: {
                                'background-image': 'data(houseSprite)',
                                'background-fit': 'contain',
                                'background-opacity': 0,
                                'shape': 'ellipse',
                                'border-width': 0,
                                'width': '60px',
                                'height': '60px',
                                'label': '',
                                'text-valign': 'bottom',
                                'text-halign': 'center',
                                'text-margin-y': 10,
                                'overlay-opacity': 0
                            }
                        },
                        {
                            selector: 'node[id = "fountain"]',
                            style: {
                                'label': '',
                                'width': '70px',
                                'height': '70px'
                            }
                        },
                        // Negative weights
                        {
                            selector: 'edge[weight < 0]',
                            style: {
                                'color': 'red',
                                'label': 'data(weight)',
                                'font-size': '12px',
                                'text-outline-width': 2,
                                'text-outline-color': 'white',
                                'text-background-color': 'white',
                                'text-background-opacity': 1,
                                'text-background-shape': 'roundrectangle',
                                'line-color': '#888',
                                'width': 3,
                                'curve-style': 'bezier',
                                'target-arrow-shape': 'triangle',
                                'target-arrow-color': '#888',
                                'mid-target-arrow-shape': 'vee',
                                'mid-target-arrow-color': '#888',
                                'mid-target-arrow-fill': 'hollow',
                                'arrow-scale': 1.5,
                                'opacity': 0.9,
                                'line-style': 'dashed',
                                'line-dash-pattern': [8, 4]
                            }
                        },
                        // Positive weights
                        {
                            selector: 'edge[weight >= 0]',
                            style: {
                                'color': 'green',
                                'label': 'data(weight)',
                                'font-size': '12px',
                                'text-outline-width': 2,
                                'text-outline-color': 'white',
                                'text-background-color': 'white',
                                'text-background-opacity': 1,
                                'text-background-shape': 'roundrectangle',
                                'line-color': '#888',
                                'width': 3,
                                'curve-style': 'bezier',
                                'target-arrow-shape': 'triangle',
                                'target-arrow-color': '#888',
                                'mid-target-arrow-shape': 'vee',
                                'mid-target-arrow-color': '#888',
                                'mid-target-arrow-fill': 'hollow',
                                'arrow-scale': 1.5,
                                'opacity': 0.9,
                                'line-style': 'dashed',
                                'line-dash-pattern': [8, 4]
                            }
                        },
                    ],
                    layout: {
                        name: 'cose',
                        animate: false
                    }
                });

                cy.fit(); // zoom graph to fit nicely

                // Animate dashed line movement (optional visual)
                let dashOffset = 0;
                setInterval(() => {
                    dashOffset = (dashOffset - 1) % 100;
                    cy.edges().forEach(edge => {
                        if (edge.style('line-style') === 'dashed') {  // ‚¨ÖÔ∏è Only if still dashed
                            edge.style('line-dash-offset', dashOffset);
                        }
                    });
                }, 60);


            } catch (e) {
                console.error("Error initializing Cytoscape:", e);
                document.getElementById('negative-cycle-graph').innerText = "Error: Could not render graph.";
            }



            const dijkstraCard = document.getElementById('dijkstra-card');
            const bellmanFordCard = document.getElementById('Bellman-Ford-card');
            const floydWarshallCard = document.getElementById('Floyd-Warshall-card');

            const dijkstraNotice = document.getElementById('algorithm-notice-dijkstra');
            const floydWarshallNotice = document.getElementById('algorithm-notice-floydwarshall');

            dijkstraCard.addEventListener('click', async () => {
                resetGraphStyles();
                if (!hasNegativeEdge) {
                    hideSelectAlgorithmButton();
                    const response = await fetch(`/village/${villageId}/dijkstra`);
                    const steps = await response.json();

                    animationSteps = steps;
                    finalizedPath = steps.filter(s => s.action === "finalize"); // << save finalized path
                    playDijkstraAnimation(animationSteps);
                    console.log("‚úÖ Dijkstra animation triggered (no negative edges).");
                } else {
                    console.log("‚ùå Negative edges detected: showing notice!");

                    let existingNotice = document.getElementById('algorithm-notice-dijkstra');
                    if (!existingNotice) {
                        const newNotice = document.createElement('div');
                        newNotice.id = 'algorithm-notice-dijkstra';
                        newNotice.style.cssText = `
                            display: block;
                            padding: 15px 20px;
                            margin: 20px auto;
                            background-color: #ff6b6b;
                            border: 1px solid #ff6b6b;
                            border-radius: 10px;
                            color: white;
                            font-weight: bold;
                            width: 80%;
                            text-align: center;
                            opacity: 0;
                        `;
                        newNotice.innerHTML = '‚ö†Ô∏è Unfortunately this village has negative edge weights, thus Dijkstra cannot be used. Try Bellman-Ford or Floyd-Warshall instead!';
                        const graphSection = document.querySelector('.graph-section');
                        graphSection.insertBefore(newNotice, document.getElementById('select-algorithm-button'));

                        setTimeout(() => {
                            newNotice.style.transition = "opacity 0.5s ease-in";
                            newNotice.style.opacity = 1;
                        }, 10);

                        // ‚ú® Auto-fade Dijkstra notice too
                        setTimeout(() => {
                            newNotice.style.transition = "opacity 0.5s ease-out";
                            newNotice.style.opacity = 0;
                            setTimeout(() => {
                                newNotice.remove();
                            }, 500);
                        }, 4000); // 5 seconds
                    }
                }
            });



            bellmanFordCard.addEventListener('click', async () => {
                resetGraphStyles();
                hideSelectAlgorithmButton();
                const response = await fetch(`/village/${villageId}/bellmanford`);
                const steps = await response.json();
                playBellmanFordAnimation(steps);
                console.log("üõ°Ô∏è Bellman-Ford animation triggered from server!");
                animationSteps = steps;
                finalizedPath = steps.filter(s => s.action === "finalize");
                playDijkstraAnimation(animationSteps);
            });

            floydWarshallCard.addEventListener('click', async () => {
                resetGraphStyles();
                hideSelectAlgorithmButton();
                console.log("üåå Clicking Floyd-Warshall card...");

                try {
                    const response = await fetch(`/village/${villageId}/floydwarshall`);
                    const steps = await response.json();
                    console.log("üåå Steps received:", steps.length, steps);

                    if (steps && steps.length > 0) {
                        playFloydWarshallAnimation(steps);
                        console.log("üåå Floyd-Warshall animation triggered!");
                        animationSteps = steps;
                        finalizedPath = steps.filter(s => s.action === "finalize");
                        playDijkstraAnimation(animationSteps);
                    } else {
                        console.log("üåå No Floyd-Warshall animation steps to play.");

                        let existingNotice = document.getElementById('algorithm-notice-floydwarshall');
                        if (!existingNotice) {
                            const newNotice = document.createElement('div');
                            newNotice.id = 'algorithm-notice-floydwarshall';
                            newNotice.style.cssText = `
                            display: block;
                            padding: 15px 20px;
                            margin: 20px auto;
                            background-color: #ff6b6b;
                            border: 1px solid #ff6b6b;
                            border-radius: 10px;
                            color: white;
                            font-weight: bold;
                            width: 80%;
                            text-align: center;
                            opacity: 0;
                        `;
                            newNotice.innerHTML = '‚ö†Ô∏è Unfortunately this village has negatives AND cycles.<br>Floyd-Warshall can process graphs with negative edge weights, however not with negative cycles.<br>Try Bellman-Ford instead!';

                            const graphSection = document.querySelector('.graph-section');
                            graphSection.insertBefore(newNotice, document.getElementById('select-algorithm-button'));

                            setTimeout(() => {
                                newNotice.style.transition = "opacity 0.5s ease-in";
                                newNotice.style.opacity = 1;
                            }, 10);

                            // ‚ú® Auto-fade away after 5 seconds
                            setTimeout(() => {
                                newNotice.style.transition = "opacity 0.5s ease-out";
                                newNotice.style.opacity = 0;
                                setTimeout(() => {
                                    newNotice.remove(); // completely remove from DOM
                                }, 500);
                            }, 7000);
                        }
                    }
                } catch (error) {
                    console.error("üåå Error while trying to fetch Floyd-Warshall animation steps:", error);
                }
            });





        });

        // ‚úÖ Dijkstra Animation Function - Animates Dijkstra's algorithm on the graph
        async function playDijkstraAnimation(steps) {
            if (isAnimating) return;  // ‚õî already playing, ignore click
            isAnimating = true;
            totalCost = 0;
            totalCostDisplay.innerText = "Total Cost: 0"; // <-- Add this
            totalCostDisplay.style.display = "none"; // hide while playing 
            const finalizedEdges = new Set(); // üü¢ to track final green connections

            for (const step of steps) {
                const edge = cy.edges().filter(e => {
                    return (e.source().id() === step.from && e.target().id() === step.to) ||
                        (e.source().id() === step.to && e.target().id() === step.from);
                });

                if (step.action === "visit") {
                    edge.forEach(e => {
                        e.style({
                            'line-color': 'orange',
                            'target-arrow-shape': 'triangle',
                            'target-arrow-color': 'orange',
                            'line-style': 'solid',
                            'width': 4,
                            'line-dash-pattern': []
                        });
                        cy.$id(step.from).style({
                            'border-width': '4px',
                            'border-color': 'orange'
                        });
                        cy.$id(step.to).style({
                            'border-width': '4px',
                            'border-color': 'orange'
                        });
                    });
                } else if (step.action === "finalize") {
                    edge.forEach(e => {
                        e.style({
                            'line-color': 'green',
                            'target-arrow-shape': 'triangle',
                            'target-arrow-color': 'green',
                            'line-style': 'solid',
                            'width': 5,
                            'line-dash-pattern': []
                        });
                        cy.$id(step.from).style({
                            'border-width': '4px',
                            'border-color': 'green'
                        });
                        cy.$id(step.to).style({
                            'border-width': '4px',
                            'border-color': 'green'
                        });

                        finalizedEdges.add(e.id()); // üü¢ Mark this edge as finalized

                        // üß† Increase cost
                        // Get actual weight from the graph
                        let actualWeight = e.data('weight');
                        totalCost += actualWeight;

                    });
                }

                await new Promise(resolve => setTimeout(resolve, 50)); // small delay between steps
                totalCostDisplay.innerText = "Total Cost: " + totalCost;
                totalCostDisplay.style.display = "block"; // ‚ú® reveal after finish 
            }
            showFinalizeNoticeAndThenSelectButton();

            // ‚ú® After ALL animations, hide the remaining orange edges
            cy.edges().forEach(edge => {
                if (!finalizedEdges.has(edge.id())) {
                    // This edge was only visited, not finalized ‚Üí hide it
                    edge.style({
                        'opacity': 0.2,         // you can also use 0 if you want it invisible
                        'line-color': '#ccc',    // optional: gray color for "inactive" edges
                        'target-arrow-color': '#ccc'
                    });
                }
            });
            isAnimating = false;

            finalizeNotice.style.display = "block";
            finalizeNotice.style.opacity = 0;
            setTimeout(() => {
                finalizeNotice.style.transition = "opacity 0.5s ease-in";
                finalizeNotice.style.opacity = 1;
            }, 10);
        }
        selectAlgorithmBtn.addEventListener('click', async () => {
            // ‚úÖ Hide the Select Algorithm button itself
            hideSelectAlgorithmButton();

            // ‚úÖ Hide algorithm cards too
            hideAlgorithmCards();

            // ‚úÖ Show Scout Messenger button
            const scoutButtonDiv = document.getElementById('scout-messanger-button');
            scoutButtonDiv.style.display = 'block';
            scoutButtonDiv.style.opacity = 0;
            setTimeout(() => {
                scoutButtonDiv.style.transition = "opacity 0.5s ease-in";
                scoutButtonDiv.style.opacity = 1;
            }, 1);
        });

        // üõ°Ô∏è Now, clicking scout button moves the messenger
        scoutMessangerBtn.addEventListener('click', async () => {
            if (finalizedPath.length === 0) {
                console.log("‚ö†Ô∏è No finalized path for messenger!");
                return;
            }

            scoutMessangerBtn.disabled = true; // üõ°Ô∏è Disable immediately
            scoutMessangerBtn.style.opacity = "0.6"; // optional: make it look faded

            await moveMessengerAlongPath(finalizedPath);
        });



        // ‚úÖ BeellmanFord Animation Function - Animates BellmanFord's algorithm on the graph
        async function playBellmanFordAnimation(steps) {
            if (isAnimating) return;  // ‚õî already playing, ignore click
            isAnimating = true;
            totalCost = 0;
            const finalizedEdges = new Set();
            const finalizeNotice = document.getElementById('finalize-notice');

            const visitSteps = steps.filter(step => step.action === "visit");
            const finalizeSteps = steps.filter(step => step.action === "finalize");

            // Phase 1: VISIT phase (blue)
            for (const step of visitSteps) {
                const edge = cy.edges().filter(edge =>
                    (edge.source().id() === step.from && edge.target().id() === step.to) ||
                    (edge.source().id() === step.to && edge.target().id() === step.from)
                );

                edge.forEach(e => {
                    e.style({
                        'line-color': '#D76400',
                        'target-arrow-color': '#D76400',
                        'line-style': 'solid',
                        'width': 4,
                        'line-dash-pattern': []
                    });
                    cy.$id(step.from).style({
                        'border-width': '4px',
                        'border-color': '#D76400'
                    });
                    cy.$id(step.to).style({
                        'border-width': '4px',
                        'border-color': '#D76400'
                    });
                });

                await new Promise(resolve => setTimeout(resolve, 8));
            }

            finalizeNotice.style.display = "block";
            finalizeNotice.style.opacity = 0;
            setTimeout(() => {
                finalizeNotice.style.transition = "opacity 0.5s ease-in";
                finalizeNotice.style.opacity = 1;
            }, 10);

            // Phase 2: FINALIZE phase (green)
            const finalizedPairs = new Set();

            for (const step of finalizeSteps) {
                const edges = cy.edges().filter(e =>
                    (e.source().id() === step.from && e.target().id() === step.to) ||
                    (e.source().id() === step.to && e.target().id() === step.from)
                );

                edges.forEach(e => {
                    e.style({
                        'line-color': 'green',
                        'target-arrow-color': 'green',
                        'line-style': 'solid',
                        'width': 5,
                        'line-dash-pattern': []
                    });
                    cy.$id(step.from).style({
                        'border-width': '4px',
                        'border-color': 'green'
                    });
                    cy.$id(step.to).style({
                        'border-width': '4px',
                        'border-color': 'green'
                    });

                    finalizedEdges.add(e.id());
                    addEdgeCostOnce(step, e, finalizedPairs);
                });

                await new Promise(resolve => setTimeout(resolve, 50));
                totalCostDisplay.innerText = "Total Cost: " + totalCost;
                totalCostDisplay.style.display = "block";
            }

            // Fade unfinished edges
            cy.edges().forEach(edge => {
                if (!finalizedEdges.has(edge.id())) {
                    edge.style({
                        'opacity': 0.2,
                        'line-color': '#ccc',
                        'target-arrow-color': '#ccc'
                    });
                }
            });

            setTimeout(() => {
                finalizeNotice.style.transition = "opacity 0.5s ease-out";
                finalizeNotice.style.opacity = 0;
                setTimeout(() => {
                    finalizeNotice.style.display = "none";
                }, 500);
            }, 1000);

            isAnimating = false;
            showFinalizeNoticeAndThenSelectButton();
        }


        async function playFloydWarshallAnimation(steps) {
            if (isAnimating) return;
            isAnimating = true;
            totalCost = 0;

            cy.edges().forEach(edge => {
                edge.style({
                    'line-color': '#888',
                    'target-arrow-color': '#888',
                    'opacity': 1,
                    'line-style': 'dashed',
                    'width': 3,
                    'line-dash-pattern': [8, 4]
                });
            });

            cy.nodes().forEach(node => {
                node.style({
                    'border-width': 0,
                    'border-color': '#000'
                });
            });

            const finalizedEdges = new Set();
            const finalizeNotice = document.getElementById('finalize-notice');

            const visitSteps = steps.filter(step => step.action === "visit");
            const finalizeSteps = steps.filter(step => step.action === "finalize");

            // Phase 1: VISIT phase (orange)
            for (const step of visitSteps) {
                const edge = cy.edges().filter(e => {
                    return (e.source().id() === step.from && e.target().id() === step.to) ||
                        (e.source().id() === step.to && e.target().id() === step.from);
                });

                if (edge.length) {
                    edge.style({
                        'line-color': 'orange',
                        'target-arrow-color': 'orange',
                        'line-style': 'solid',
                        'width': 4,
                        'line-dash-pattern': []
                    });
                    cy.$id(step.from).style({
                        'border-width': '4px',
                        'border-color': 'orange'
                    });
                    cy.$id(step.to).style({
                        'border-width': '4px',
                        'border-color': 'orange'
                    });
                }

                await new Promise(resolve => setTimeout(resolve, 8));
            }

            finalizeNotice.style.display = "block";
            finalizeNotice.style.opacity = 0;
            setTimeout(() => {
                finalizeNotice.style.transition = "opacity 0.5s ease-in";
                finalizeNotice.style.opacity = 1;
            }, 10);

            // Phase 2: FINALIZE phase (green)
            const finalizedPairs = new Set();

            for (const step of finalizeSteps) {
                const edge = cy.edges().filter(e => {
                    return (e.source().id() === step.from && e.target().id() === step.to) ||
                        (e.source().id() === step.to && e.target().id() === step.from);
                });

                if (edge.length) {
                    edge.style({
                        'line-color': 'green',
                        'target-arrow-color': 'green',
                        'line-style': 'solid',
                        'width': 5,
                        'line-dash-pattern': []
                    });
                    cy.$id(step.from).style({
                        'border-width': '4px',
                        'border-color': 'green'
                    });
                    cy.$id(step.to).style({
                        'border-width': '4px',
                        'border-color': 'green'
                    });

                    finalizedEdges.add(edge.id());
                    addEdgeCostOnce(step, edge, finalizedPairs);
                }

                await new Promise(resolve => setTimeout(resolve, 50));
                totalCostDisplay.innerText = "Total Cost: " + totalCost;
                totalCostDisplay.style.display = "block";
            }

            cy.edges().forEach(edge => {
                if (!finalizedEdges.has(edge.id())) {
                    edge.style({
                        'opacity': 0.2,
                        'line-color': '#ccc',
                        'target-arrow-color': '#ccc'
                    });
                }
            });

            setTimeout(() => {
                finalizeNotice.style.transition = "opacity 0.5s ease-out";
                finalizeNotice.style.opacity = 0;
                setTimeout(() => {
                    finalizeNotice.style.display = "none";
                }, 500);
            }, 700);

            isAnimating = false;
            showFinalizeNoticeAndThenSelectButton();
        }

        function moveMessengerAlongPath(steps) {
            if (steps.length === 0) return;

            const messenger = document.getElementById('messenger');
            messenger.style.display = 'block'; // Show the messenger
            messenger.style.position = 'absolute';
            messenger.style.zIndex = '9999';
            messenger.style.pointerEvents = 'none'; // Don't block mouse

            const graphRect = document.getElementById('negative-cycle-graph').getBoundingClientRect();

            async function walkFromTo(fromNode, toNode, forward = true) {
                const start = cy.$id(fromNode).renderedPosition();
                const end = cy.$id(toNode).renderedPosition();

                const stepsCount = 100; // how many points between start and end
                for (let i = 0; i <= stepsCount; i++) {
                    const t = forward ? i / stepsCount : (stepsCount - i) / stepsCount;
                    const x = start.x * (1 - t) + end.x * t;
                    const y = start.y * (1 - t) + end.y * t;

                    messenger.style.left = `${graphRect.left + x - 40}px`; // -40 to center
                    messenger.style.top = `${graphRect.top + y - 60}px`;   // -60 to center vertically

                    await new Promise(resolve => setTimeout(resolve, 10)); // 10ms per small step
                }
            }

            async function walkFullPath(pathSteps, forward = true) {
                for (let i = 0; i < pathSteps.length; i++) {
                    const step = forward ? pathSteps[i] : pathSteps[pathSteps.length - 1 - i];
                    await walkFromTo(step.from, step.to, forward);
                }
            }

            (async () => {
                await walkFullPath(steps, true); // üö∂ Go forward

                // üó®Ô∏è Create returning message
                const label = document.createElement('div');
                label.innerText = 'üìú Returning with news...';
                label.style.marginBottom = '10px';
                label.style.padding = '5px 10px';
                label.style.backgroundColor = '#333';
                label.style.color = 'white';
                label.style.borderRadius = '8px';
                label.style.fontWeight = 'bold';
                label.style.fontSize = '25px';
                label.style.textAlign = 'center';
                label.style.zIndex = '1000';

                const graphSection = document.querySelector('.graph-section');
                const totalCostDiv = document.getElementById('total-cost-display');
                graphSection.insertBefore(label, totalCostDiv);

                await new Promise(r => setTimeout(r, 1500));

                await walkFullPath(steps, false); // üö∂ Come back

                messenger.style.display = 'none';
                label.remove();
                // üõ°Ô∏è After returning: Show resources
                const resourcesMessage = document.getElementById('resources-message');
                const resourcesList = document.getElementById('resources-list');

                if (resourcesMessage && resourcesList) {
                    resourcesMessage.style.display = 'none';  // hide the gathering message
                    resourcesList.style.display = 'block';     // show the real resources
                    // üõ°Ô∏è Update global resources with THIS village's resources
                    globalResources.food += parseInt(document.querySelector('#resources-list span[th\\:text$="village.food"]').innerText || 0);
                    globalResources.wood += parseInt(document.querySelector('#resources-list span[th\\:text$="village.wood"]').innerText || 0);
                    globalResources.rocks += parseInt(document.querySelector('#resources-list span[th\\:text$="village.rocks"]').innerText || 0);
                    globalResources.iron += parseInt(document.querySelector('#resources-list span[th\\:text$="village.iron"]').innerText || 0);
                    globalResources.coal += parseInt(document.querySelector('#resources-list span[th\\:text$="village.coal"]').innerText || 0);
                    globalResources.villagers += parseInt(document.querySelector('#resources-list span[th\\:text$="village.villagers"]').innerText || 0);
                    globalResources.knights += parseInt(document.querySelector('#resources-list span[th\\:text$="village.knights"]').innerText || 0);

                    console.log("‚úÖ Resources collected so far:", globalResources);

                }
                document.getElementById('total-food').innerText = globalResources.food;
                document.getElementById('total-wood').innerText = globalResources.wood;
                document.getElementById('total-rocks').innerText = globalResources.rocks;
                document.getElementById('total-iron').innerText = globalResources.iron;
                document.getElementById('total-coal').innerText = globalResources.coal;
                document.getElementById('total-villagers').innerText = globalResources.villagers;
                document.getElementById('total-knights').innerText = globalResources.knights;

                // Send updated resources to the server
                fetch('/updateResources', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(globalResources)
                })
                .then(response => {
                    if (response.ok) {
                        console.log('Resources updated on server');
                    } else {
                        console.error('Failed to update resources on server');
                    }
                })
                .finally(() => {
                    window.location.href = "/hello";
                });

            })();
        }


        var hasNegativeEdge = /*[[${hasNegativeEdge}]]*/ false; // only declare ONCE


        function addEdgeCostOnce(step, edge, finalizedPairs) {
            const key1 = step.from + "-" + step.to;
            const key2 = step.to + "-" + step.from;
            if (!finalizedPairs.has(key1) && !finalizedPairs.has(key2)) {
                let weight = edge.data('weight') || 0;
                totalCost += weight;
                finalizedPairs.add(key1);
                finalizedPairs.add(key2);
            }
        }

        function hideSelectAlgorithmButton() {
            const selectButtonDiv = document.getElementById('select-algorithm-button');
            if (selectButtonDiv.style.display !== "none") {
                selectButtonDiv.style.transition = "opacity 0.5s ease-out, margin 0.5s ease-out, height 0.5s ease-out";
                selectButtonDiv.style.opacity = 0;
                selectButtonDiv.style.marginTop = "0px"; // üëà shrink the margin
                selectButtonDiv.style.height = "0px";    // üëà shrink the height

                setTimeout(() => {
                    selectButtonDiv.style.display = "none";
                }, 500); // wait for fade & shrink to finish
            }
        }

        function hideAlgorithmCards() {
            const bottomCards = document.querySelector('.bottom-cards');
            if (bottomCards) {
                bottomCards.style.transition = "opacity 0.5s ease-out, margin 0.5s ease-out, height 0.5s ease-out";
                bottomCards.style.opacity = 0;
                bottomCards.style.marginTop = "0px";
                bottomCards.style.height = "0px";

                setTimeout(() => {
                    bottomCards.style.display = "none";
                }, 500);
            }
        }

        function showFinalizeNoticeAndThenSelectButton() {
            const finalizeNotice = document.getElementById('finalize-notice');
            finalizeNotice.style.display = "block";
            finalizeNotice.style.opacity = 0;

            setTimeout(() => {
                finalizeNotice.style.transition = "opacity 0.5s ease-in";
                finalizeNotice.style.opacity = 1;
            }, 10);

            // ‚è≥ After 2 seconds, fade it out
            setTimeout(() => {
                finalizeNotice.style.transition = "opacity 0.5s ease-out";
                finalizeNotice.style.opacity = 0;

                setTimeout(() => {
                    finalizeNotice.style.display = "none";
                    // ‚ú® Now show select algorithm button
                    const selectButtonDiv = document.getElementById('select-algorithm-button');
                    selectButtonDiv.style.display = 'block';
                    selectButtonDiv.style.opacity = 0;
                    setTimeout(() => {
                        selectButtonDiv.style.transition = "opacity 0.5s ease-in";
                        selectButtonDiv.style.opacity = 1;
                    }, 10);
                }, 100); // after fadeout
            }, 1000); // 2 seconds shown
        }

        function resetGraphStyles() {
            if (!cy) return;

            cy.edges().forEach(edge => {
                edge.style({
                    'opacity': 1,
                    'line-color': '#888',
                    'target-arrow-color': '#888',
                    'line-style': edge.data('weight') < 0 ? 'dashed' : 'dashed',
                    'line-dash-pattern': [8, 4],
                    'width': 3
                });
            });

            cy.nodes().forEach(node => {
                node.style({
                    'border-width': 0,
                    'border-color': '#000'
                });
            });
        }




        /*]]>*/
    </script>


</body>

</html>
