<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">

<head>
    <meta charset="UTF-8">
    <!-- Sets the title of the page dynamically using Thymeleaf -->
    <title th:text="'Village of ' + ${village.name}">Village Info</title>
    <!-- Cytoscape.js library for graph visualization -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.21.0/cytoscape.min.js"
        crossorigin="anonymous"></script>

    <style>
        /* Basic styling for the page */
        body {
            min-height: 100vh;
            /* üåü important: at least full height, but can grow */
            overflow-y: auto;
            /* üåü allow vertical scroll if needed */
            margin: 0;
            padding: 0;
            font-family: sans-serif;
            display: flex;
            flex-direction: row;
            justify-content: flex-start;
            align-items: flex-start;
        }


        /* Style for the village information card on the left */
        .village-card {
            background-color: #fff;
            border-radius: 12px;
            padding: 20px 25px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
            width: 400px;
            height: auto;
            max-height: 90vh;
            overflow-y: auto;
            margin: 40px 20px 0 40px;
            color: #454e4e;
            font-weight: bold;
        }

        /* Style for the village image */
        .village-card img {
            width: 100px;
            height: auto;
            margin-bottom: 15px;
        }

        /* Style for the graph section on the right */
        .graph-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 40px;
            flex-grow: 1;
        }

        /* Style for the graph canvas */
        #negative-cycle-graph {
            flex-grow: 1;
            margin: 20px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
            background-color: #ffffff;
            border-radius: 12px;
            height: calc(70vh);
            /* Graph height smaller to leave space for bottom cards */
            width: 80%;
        }

        /* Style for the bottom cards container */
        .bottom-cards {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 20px;
            gap: 20px;
        }

        /* Style for the square cards */
        .square-card {
            background-color: white;
            width: 150px;
            height: 150px;
            border-radius: 12px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #454e4e;
            transition: transform 0.3s, box-shadow 0.3s;
        }

        /* Hover effect for the square cards */
        .square-card:hover {
            transform: scale(1.05);
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.2);
        }
    </style>
</head>

<body>

    <!-- Left Side Village Info - Contains details about the selected village -->
    <div class="village-card">
        <!-- Village Name - Dynamically set using Thymeleaf -->
        <h1 th:text="${village.formattedName}">Village Name</h1>
        <!-- Village Sprite - Dynamically set using Thymeleaf to display the village's image -->
        <img th:src="@{${village.sprite}}" alt="Village Sprite" />
        <!-- Village Population - Dynamically set using Thymeleaf -->
        <p><strong>Population:</strong> <span th:text="${village.population}">0</span></p>
        <!-- Village Structures - Dynamically set using Thymeleaf -->
        <p><strong>Structures:</strong> <span th:text="${village.structures}">0</span></p>
        <!-- Village Coordinates - Dynamically set using Thymeleaf -->
        <p><strong>Coordinates:</strong> (<span th:text="${village.xCoordinate}">x</span>, <span
                th:text="${village.yCoordinate}">y</span>)</p>
        <hr>
        <!-- Village Resources Section -->
        <h3>Resources</h3>
        <!-- Food Resource - Dynamically set using Thymeleaf -->
        <p><strong>Food:</strong> <span th:text="${village.food}">0</span></p>
        <!-- Wood Resource - Dynamically set using Thymeleaf -->
        <p><strong>Wood:</strong> <span th:text="${village.wood}">0</span></p>
        <!-- Rocks Resource - Dynamically set using Thymeleaf -->
        <p><strong>Rocks:</strong> <span th:text="${village.rocks}">0</span></p>
        <!-- Iron Resource - Dynamically set using Thymeleaf -->
        <p><strong>Iron:</strong> <span th:text="${village.iron}">0</span></p>
        <!-- Coal Resource - Dynamically set using Thymeleaf -->
        <p><strong>Coal:</strong> <span th:text="${village.coal}">0</span></p>
        <!-- Villagers Count - Dynamically set using Thymeleaf -->
        <p><strong>Villagers:</strong> <span th:text="${village.villagers}">0</span></p>
        <!-- Knights Count - Dynamically set using Thymeleaf -->
        <p><strong>Knights:</strong> <span th:text="${village.knights}">0</span></p>
        <!-- Back to Map Link - A link to return to the main map -->
        <a href="/hello" style="color:#009a7e; text-decoration: none;">‚Üê Back to Map</a>
    </div>

    <!-- Right Side Graph + Cards - Contains the graph visualization and algorithm selection cards -->
    <div class="graph-section">
        <div id="total-cost-display"
            style="margin-top: 10px; font-size: 20px; font-weight: bold; color: #006400; display: none;">
            Total Cost: 0
        </div>
        <!-- Graph Canvas - Where the Cytoscape graph will be rendered -->
        <div id="negative-cycle-graph"></div>

        <div id="finalize-notice" style="display: none; padding: 10px 15px; margin: 10px auto; background-color: #058963; 
        border: 1px solid #00ffbb9b; border-radius: 8px; color: #ffffff; font-weight: bold; 
        width: 60%; text-align: center;">
            üõ°Ô∏è Best Path calculation completed!
        </div>

        <!-- Select Algorithm Button -->
        <div id="select-algorithm-button" style="display: none; margin-top: 20px; text-align: center;">
            <button
                style="padding: 15px 20px; font-size: 18px; background-color: #058963; color: white; border: none; border-radius: 10px; cursor: pointer;">
                Select Algorithm
            </button>
        </div>

        <!-- Bottom Cards - Algorithm selection cards -->
        <div class="bottom-cards">
            <!-- Dijkstra Card - Card to trigger Dijkstra's algorithm animation -->
            <div class="square-card" id="dijkstra-card">Dijkstra</div>
            <!-- Floyd-Warshall Card - Card to trigger Floyd-Warshall algorithm animation -->
            <div class="square-card" id="Floyd-Warshall-card">Floyd-Warshall</div>
            <!-- Bellman-Ford Card - Card to trigger Bellman-Ford algorithm animation -->
            <div class="square-card" id="Bellman-Ford-card">Bellman-Ford</div>
        </div>
    </div>


    <!-- Cytoscape Graph Script - JavaScript code to render and interact with the graph -->
    <script th:inline="javascript">
        /*<![CDATA[*/
        // GLOBAL variables here:
        const villageId = /*[[${village.id}]]*/ 0;
        let totalCost = 0; // üõ°Ô∏è global tracker
        const totalCostDisplay = document.getElementById('total-cost-display');
        var parsedData = {}; // global
        var graphData = /*[[${graphData}]]*/ '[]'; // global graph JSON 
        var cy; // global Cytoscape instance
        let isAnimating = false;


        // Event listener that triggers when the document is fully loaded
        document.addEventListener('DOMContentLoaded', function () {
            isAnimating = false;   // ‚úÖ Reset animating flag
            totalCost = 0;         // ‚úÖ Reset cost

            if (cy) {
                cy.destroy(); // üî• DESTROY the old graph
            }

            try {
                // Parse the graph data from JSON format
                parsedData = JSON.parse(graphData);

                // Initialize Cytoscape graph
                cy = cytoscape({
                    container: document.getElementById('negative-cycle-graph'),
                    elements: parsedData.nodes.concat(parsedData.edges),
                    style: [
                        {
                            selector: 'node',
                            style: {
                                'background-image': 'data(houseSprite)',
                                'background-fit': 'contain',
                                'background-opacity': 0,
                                'shape': 'ellipse',
                                'border-width': 0,
                                'width': '60px',
                                'height': '60px',
                                'label': '',
                                'text-valign': 'bottom',
                                'text-halign': 'center',
                                'text-margin-y': 10,
                                'overlay-opacity': 0
                            }
                        },
                        {
                            selector: 'node[id = "fountain"]',
                            style: {
                                'label': '',
                                'width': '70px',
                                'height': '70px'
                            }
                        },
                        // Negative weights
                        {
                            selector: 'edge[weight < 0]',
                            style: {
                                'color': 'red',
                                'label': 'data(weight)',
                                'font-size': '12px',
                                'text-outline-width': 2,
                                'text-outline-color': 'white',
                                'text-background-color': 'white',
                                'text-background-opacity': 1,
                                'text-background-shape': 'roundrectangle',
                                'line-color': '#888',
                                'width': 3,
                                'curve-style': 'bezier',
                                'target-arrow-shape': 'triangle',
                                'target-arrow-color': '#888',
                                'mid-target-arrow-shape': 'vee',
                                'mid-target-arrow-color': '#888',
                                'mid-target-arrow-fill': 'hollow',
                                'arrow-scale': 1.5,
                                'opacity': 0.9,
                                'line-style': 'dashed',
                                'line-dash-pattern': [8, 4]
                            }
                        },
                        // Positive weights
                        {
                            selector: 'edge[weight >= 0]',
                            style: {
                                'color': 'green',
                                'label': 'data(weight)',
                                'font-size': '12px',
                                'text-outline-width': 2,
                                'text-outline-color': 'white',
                                'text-background-color': 'white',
                                'text-background-opacity': 1,
                                'text-background-shape': 'roundrectangle',
                                'line-color': '#888',
                                'width': 3,
                                'curve-style': 'bezier',
                                'target-arrow-shape': 'triangle',
                                'target-arrow-color': '#888',
                                'mid-target-arrow-shape': 'vee',
                                'mid-target-arrow-color': '#888',
                                'mid-target-arrow-fill': 'hollow',
                                'arrow-scale': 1.5,
                                'opacity': 0.9,
                                'line-style': 'dashed',
                                'line-dash-pattern': [8, 4]
                            }
                        },
                    ],
                    layout: {
                        name: 'cose',
                        animate: false
                    }
                });

                cy.fit(); // zoom graph to fit nicely

                // Animate dashed line movement (optional visual)
                let dashOffset = 0;
                setInterval(() => {
                    dashOffset = (dashOffset - 1) % 100;
                    cy.edges().forEach(edge => {
                        if (edge.style('line-style') === 'dashed') {  // ‚¨ÖÔ∏è Only if still dashed
                            edge.style('line-dash-offset', dashOffset);
                        }
                    });
                }, 60);


            } catch (e) {
                console.error("Error initializing Cytoscape:", e);
                document.getElementById('negative-cycle-graph').innerText = "Error: Could not render graph.";
            }



            const dijkstraCard = document.getElementById('dijkstra-card');
            const bellmanFordCard = document.getElementById('Bellman-Ford-card');
            const floydWarshallCard = document.getElementById('Floyd-Warshall-card');

            const dijkstraNotice = document.getElementById('algorithm-notice-dijkstra');
            const floydWarshallNotice = document.getElementById('algorithm-notice-floydwarshall');

            dijkstraCard.addEventListener('click', async () => {
                if (!hasNegativeEdge) {
                    hideSelectAlgorithmButton();
                    const response = await fetch(`/village/${villageId}/dijkstra`);
                    const steps = await response.json();

                    animationSteps = steps;
                    playDijkstraAnimation(animationSteps);
                    console.log("‚úÖ Dijkstra animation triggered (no negative edges).");
                } else {
                    console.log("‚ùå Negative edges detected: showing notice!");

                    let existingNotice = document.getElementById('algorithm-notice-dijkstra');
                    if (!existingNotice) {
                        const newNotice = document.createElement('div');
                        newNotice.id = 'algorithm-notice-dijkstra';
                        newNotice.style.cssText = `
                            display: block;
                            padding: 15px 20px;
                            margin: 20px auto;
                            background-color: #ff6b6b;
                            border: 1px solid #ff6b6b;
                            border-radius: 10px;
                            color: white;
                            font-weight: bold;
                            width: 80%;
                            text-align: center;
                            opacity: 0;
                        `;
                        newNotice.innerHTML = '‚ö†Ô∏è Unfortunately this village has negative edge weights, thus Dijkstra cannot be used. Try Bellman-Ford or Floyd-Warshall instead!';
                        const graphSection = document.querySelector('.graph-section');
                        graphSection.insertBefore(newNotice, document.getElementById('select-algorithm-button'));

                        setTimeout(() => {
                            newNotice.style.transition = "opacity 0.5s ease-in";
                            newNotice.style.opacity = 1;
                        }, 10);

                        // ‚ú® Auto-fade Dijkstra notice too
                        setTimeout(() => {
                            newNotice.style.transition = "opacity 0.5s ease-out";
                            newNotice.style.opacity = 0;
                            setTimeout(() => {
                                newNotice.remove();
                            }, 500);
                        }, 4000); // 5 seconds
                    }
                }
            });



            bellmanFordCard.addEventListener('click', async () => {
                hideSelectAlgorithmButton();
                const response = await fetch(`/village/${villageId}/bellmanford`);
                const steps = await response.json();
                playBellmanFordAnimation(steps);
                console.log("üõ°Ô∏è Bellman-Ford animation triggered from server!");
            });

            floydWarshallCard.addEventListener('click', async () => {
                hideSelectAlgorithmButton();
                console.log("üåå Clicking Floyd-Warshall card...");

                try {
                    const response = await fetch(`/village/${villageId}/floydwarshall`);
                    const steps = await response.json();
                    console.log("üåå Steps received:", steps.length, steps);

                    if (steps && steps.length > 0) {
                        playFloydWarshallAnimation(steps);
                        console.log("üåå Floyd-Warshall animation triggered!");
                    } else {
                        console.log("üåå No Floyd-Warshall animation steps to play.");

                        let existingNotice = document.getElementById('algorithm-notice-floydwarshall');
                        if (!existingNotice) {
                            const newNotice = document.createElement('div');
                            newNotice.id = 'algorithm-notice-floydwarshall';
                            newNotice.style.cssText = `
                            display: block;
                            padding: 15px 20px;
                            margin: 20px auto;
                            background-color: #ff6b6b;
                            border: 1px solid #ff6b6b;
                            border-radius: 10px;
                            color: white;
                            font-weight: bold;
                            width: 80%;
                            text-align: center;
                            opacity: 0;
                        `;
                        newNotice.innerHTML = '‚ö†Ô∏è Unfortunately this village has negatives AND cycles.<br>Floyd-Warshall can process graphs with negative edge weights, however not with negative cycles.<br>Try Bellman-Ford instead!';

                            const graphSection = document.querySelector('.graph-section');
                            graphSection.insertBefore(newNotice, document.getElementById('select-algorithm-button'));

                            setTimeout(() => {
                                newNotice.style.transition = "opacity 0.5s ease-in";
                                newNotice.style.opacity = 1;
                            }, 10);

                            // ‚ú® Auto-fade away after 5 seconds
                            setTimeout(() => {
                                newNotice.style.transition = "opacity 0.5s ease-out";
                                newNotice.style.opacity = 0;
                                setTimeout(() => {
                                    newNotice.remove(); // completely remove from DOM
                                }, 500);
                            }, 7000);
                        }
                    }
                } catch (error) {
                    console.error("üåå Error while trying to fetch Floyd-Warshall animation steps:", error);
                }
            });





        });

        // ‚úÖ Dijkstra Animation Function - Animates Dijkstra's algorithm on the graph
        async function playDijkstraAnimation(steps) {
            if (isAnimating) return;  // ‚õî already playing, ignore click
            isAnimating = true;
            totalCost = 0;
            totalCostDisplay.innerText = "Total Cost: 0"; // <-- Add this
            totalCostDisplay.style.display = "none"; // hide while playing 
            const finalizedEdges = new Set(); // üü¢ to track final green connections

            for (const step of steps) {
                const edge = cy.edges().filter(e => {
                    return (e.source().id() === step.from && e.target().id() === step.to) ||
                        (e.source().id() === step.to && e.target().id() === step.from);
                });

                if (step.action === "visit") {
                    edge.forEach(e => {
                        e.style({
                            'line-color': 'orange',
                            'target-arrow-shape': 'triangle',
                            'target-arrow-color': 'orange',
                            'line-style': 'solid',
                            'width': 4,
                            'line-dash-pattern': []
                        });
                        cy.$id(step.from).style({
                            'border-width': '4px',
                            'border-color': 'orange'
                        });
                        cy.$id(step.to).style({
                            'border-width': '4px',
                            'border-color': 'orange'
                        });
                    });
                } else if (step.action === "finalize") {
                    edge.forEach(e => {
                        e.style({
                            'line-color': 'green',
                            'target-arrow-shape': 'triangle',
                            'target-arrow-color': 'green',
                            'line-style': 'solid',
                            'width': 5,
                            'line-dash-pattern': []
                        });
                        cy.$id(step.from).style({
                            'border-width': '4px',
                            'border-color': 'green'
                        });
                        cy.$id(step.to).style({
                            'border-width': '4px',
                            'border-color': 'green'
                        });

                        finalizedEdges.add(e.id()); // üü¢ Mark this edge as finalized

                        // üß† Increase cost
                        // Get actual weight from the graph
                        let actualWeight = e.data('weight');
                        totalCost += actualWeight;

                    });
                }

                await new Promise(resolve => setTimeout(resolve, 50)); // small delay between steps
                totalCostDisplay.innerText = "Total Cost: " + totalCost;
                totalCostDisplay.style.display = "block"; // ‚ú® reveal after finish

            }

            // ‚ú® After ALL animations, hide the remaining orange edges
            cy.edges().forEach(edge => {
                if (!finalizedEdges.has(edge.id())) {
                    // This edge was only visited, not finalized ‚Üí hide it
                    edge.style({
                        'opacity': 0.2,         // you can also use 0 if you want it invisible
                        'line-color': '#ccc',    // optional: gray color for "inactive" edges
                        'target-arrow-color': '#ccc'
                    });
                }
            });
            isAnimating = false;
            document.getElementById('select-algorithm-button').style.display = 'block';
        }

        // ‚úÖ BeellmanFord Animation Function - Animates BellmanFord's algorithm on the graph
        async function playBellmanFordAnimation(steps) {
            if (isAnimating) return;  // ‚õî already playing, ignore click
            isAnimating = true;
            totalCost = 0;
            const finalizedEdges = new Set();
            const finalizeNotice = document.getElementById('finalize-notice');

            const visitSteps = steps.filter(step => step.action === "visit");
            const finalizeSteps = steps.filter(step => step.action === "finalize");

            // Phase 1: VISIT phase (blue)
            for (const step of visitSteps) {
                const edge = cy.edges().filter(edge =>
                    (edge.source().id() === step.from && edge.target().id() === step.to) ||
                    (edge.source().id() === step.to && edge.target().id() === step.from)
                );

                edge.forEach(e => {
                    e.style({
                        'line-color': '#D76400',
                        'target-arrow-color': '#D76400',
                        'line-style': 'solid',
                        'width': 4,
                        'line-dash-pattern': []
                    });
                    cy.$id(step.from).style({
                        'border-width': '4px',
                        'border-color': '#D76400'
                    });
                    cy.$id(step.to).style({
                        'border-width': '4px',
                        'border-color': '#D76400'
                    });
                });

                await new Promise(resolve => setTimeout(resolve, 8));
            }

            finalizeNotice.style.display = "block";
            finalizeNotice.style.opacity = 0;
            setTimeout(() => {
                finalizeNotice.style.transition = "opacity 0.5s ease-in";
                finalizeNotice.style.opacity = 1;
            }, 10);

            // Phase 2: FINALIZE phase (green)
            const finalizedPairs = new Set();

            for (const step of finalizeSteps) {
                const edges = cy.edges().filter(e =>
                    (e.source().id() === step.from && e.target().id() === step.to) ||
                    (e.source().id() === step.to && e.target().id() === step.from)
                );

                edges.forEach(e => {
                    e.style({
                        'line-color': 'green',
                        'target-arrow-color': 'green',
                        'line-style': 'solid',
                        'width': 5,
                        'line-dash-pattern': []
                    });
                    cy.$id(step.from).style({
                        'border-width': '4px',
                        'border-color': 'green'
                    });
                    cy.$id(step.to).style({
                        'border-width': '4px',
                        'border-color': 'green'
                    });

                    finalizedEdges.add(e.id());
                    addEdgeCostOnce(step, e, finalizedPairs);
                });

                await new Promise(resolve => setTimeout(resolve, 50));
                totalCostDisplay.innerText = "Total Cost: " + totalCost;
                totalCostDisplay.style.display = "block";
            }

            // Fade unfinished edges
            cy.edges().forEach(edge => {
                if (!finalizedEdges.has(edge.id())) {
                    edge.style({
                        'opacity': 0.2,
                        'line-color': '#ccc',
                        'target-arrow-color': '#ccc'
                    });
                }
            });

            setTimeout(() => {
                finalizeNotice.style.transition = "opacity 0.5s ease-out";
                finalizeNotice.style.opacity = 0;
                setTimeout(() => {
                    finalizeNotice.style.display = "none";
                }, 500);
            }, 1000);

            isAnimating = false;
            document.getElementById('select-algorithm-button').style.display = 'block';
        }


        async function playFloydWarshallAnimation(steps) {
            if (isAnimating) return;
            isAnimating = true;
            totalCost = 0;

            cy.edges().forEach(edge => {
                edge.style({
                    'line-color': '#888',
                    'target-arrow-color': '#888',
                    'opacity': 1,
                    'line-style': 'dashed',
                    'width': 3,
                    'line-dash-pattern': [8, 4]
                });
            });

            cy.nodes().forEach(node => {
                node.style({
                    'border-width': 0,
                    'border-color': '#000'
                });
            });

            const finalizedEdges = new Set();
            const finalizeNotice = document.getElementById('finalize-notice');

            const visitSteps = steps.filter(step => step.action === "visit");
            const finalizeSteps = steps.filter(step => step.action === "finalize");

            // Phase 1: VISIT phase (orange)
            for (const step of visitSteps) {
                const edge = cy.edges().filter(e => {
                    return (e.source().id() === step.from && e.target().id() === step.to) ||
                        (e.source().id() === step.to && e.target().id() === step.from);
                });

                if (edge.length) {
                    edge.style({
                        'line-color': 'orange',
                        'target-arrow-color': 'orange',
                        'line-style': 'solid',
                        'width': 4,
                        'line-dash-pattern': []
                    });
                    cy.$id(step.from).style({
                        'border-width': '4px',
                        'border-color': 'orange'
                    });
                    cy.$id(step.to).style({
                        'border-width': '4px',
                        'border-color': 'orange'
                    });
                }

                await new Promise(resolve => setTimeout(resolve, 8));
            }

            finalizeNotice.style.display = "block";
            finalizeNotice.style.opacity = 0;
            setTimeout(() => {
                finalizeNotice.style.transition = "opacity 0.5s ease-in";
                finalizeNotice.style.opacity = 1;
            }, 10);

            // Phase 2: FINALIZE phase (green)
            const finalizedPairs = new Set();

            for (const step of finalizeSteps) {
                const edge = cy.edges().filter(e => {
                    return (e.source().id() === step.from && e.target().id() === step.to) ||
                        (e.source().id() === step.to && e.target().id() === step.from);
                });

                if (edge.length) {
                    edge.style({
                        'line-color': 'green',
                        'target-arrow-color': 'green',
                        'line-style': 'solid',
                        'width': 5,
                        'line-dash-pattern': []
                    });
                    cy.$id(step.from).style({
                        'border-width': '4px',
                        'border-color': 'green'
                    });
                    cy.$id(step.to).style({
                        'border-width': '4px',
                        'border-color': 'green'
                    });

                    finalizedEdges.add(edge.id());
                    addEdgeCostOnce(step, edge, finalizedPairs);
                }

                await new Promise(resolve => setTimeout(resolve, 50));
                totalCostDisplay.innerText = "Total Cost: " + totalCost;
                totalCostDisplay.style.display = "block";
            }

            cy.edges().forEach(edge => {
                if (!finalizedEdges.has(edge.id())) {
                    edge.style({
                        'opacity': 0.2,
                        'line-color': '#ccc',
                        'target-arrow-color': '#ccc'
                    });
                }
            });

            setTimeout(() => {
                finalizeNotice.style.transition = "opacity 0.5s ease-out";
                finalizeNotice.style.opacity = 0;
                setTimeout(() => {
                    finalizeNotice.style.display = "none";
                }, 500);
            }, 700);

            isAnimating = false;
            document.getElementById('select-algorithm-button').style.display = 'block';
        }

        var hasNegativeEdge = /*[[${hasNegativeEdge}]]*/ false; // only declare ONCE


        function addEdgeCostOnce(step, edge, finalizedPairs) {
            const key1 = step.from + "-" + step.to;
            const key2 = step.to + "-" + step.from;
            if (!finalizedPairs.has(key1) && !finalizedPairs.has(key2)) {
                let weight = edge.data('weight') || 0;
                totalCost += weight;
                finalizedPairs.add(key1);
                finalizedPairs.add(key2);
            }
        }

        function hideSelectAlgorithmButton() {
            const selectButtonDiv = document.getElementById('select-algorithm-button');
            if (selectButtonDiv.style.display !== "none") {
                selectButtonDiv.style.transition = "opacity 0.5s ease-out, margin 0.5s ease-out, height 0.5s ease-out";
                selectButtonDiv.style.opacity = 0;
                selectButtonDiv.style.marginTop = "0px"; // üëà shrink the margin
                selectButtonDiv.style.height = "0px";    // üëà shrink the height

                setTimeout(() => {
                    selectButtonDiv.style.display = "none";
                }, 500); // wait for fade & shrink to finish
            }
        }
        function hideSelectAlgorithmButton() {
            const selectButtonDiv = document.getElementById('select-algorithm-button');
            if (selectButtonDiv.style.display !== "none") {
                selectButtonDiv.style.transition = "opacity 0.5s ease-out, margin 0.5s ease-out, height 0.5s ease-out";
                selectButtonDiv.style.opacity = 0;
                selectButtonDiv.style.marginTop = "0px"; // üëà shrink the margin
                selectButtonDiv.style.height = "0px";    // üëà shrink the height

                setTimeout(() => {
                    selectButtonDiv.style.display = "none";
                }, 500); // wait for fade & shrink to finish
            }
        }
        function hideSelectAlgorithmButton() {
            const selectButtonDiv = document.getElementById('select-algorithm-button');
            if (selectButtonDiv.style.display !== "none") {
                selectButtonDiv.style.transition = "opacity 0.5s ease-out, margin 0.5s ease-out, height 0.5s ease-out";
                selectButtonDiv.style.opacity = 0;
                selectButtonDiv.style.marginTop = "0px"; // üëà shrink the margin
                selectButtonDiv.style.height = "0px";    // üëà shrink the height

                setTimeout(() => {
                    selectButtonDiv.style.display = "none";
                }, 500); // wait for fade & shrink to finish
            }
        }


        /*]]>*/
    </script>


</body>

</html>